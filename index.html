<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Numeric Key Generator</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #232946;
            --bg-tertiary: #2e3450;
            --accent-primary: #6c5ce7;
            --accent-secondary: #ffb7c5;
            --text-primary: #f1f5f9;
            --text-secondary: #b0c0d8;
            --success: #10b981;
            --error: #dc2626;
            --border: #4b587c;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            margin: 0;
            padding: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        
        .container {
            max-width: 1000px;
            width: 100%;
            background: var(--bg-secondary);
            padding: 2.5rem;
            border-radius: 1.2rem;
            box-shadow: 0 12px 30px rgba(0,0,0,0.4);
            border: 1px solid var(--border);
        }
        
        h1, h2, h3 {
            color: var(--text-primary);
            font-weight: 700;
            margin-bottom: 0.75rem;
        }
        
        h1 {
            font-size: 2.75rem;
            text-align: center;
            margin-bottom: 2.5rem;
            color: var(--accent-secondary);
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header-subtitle {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 2rem;
            font-size: 1.1rem;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .controls {
            margin-bottom: 2.5rem;
            padding: 1.75rem;
            border-radius: 1rem;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.75rem;
            align-items: center;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        label {
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
        }
        
        input[type="number"] {
            padding: 0.85rem;
            border: 1px solid var(--border);
            border-radius: 0.6rem;
            font-size: 1.05rem;
            width: 120px;
            text-align: center;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(108, 92, 231, 0.2);
        }
        
        button {
            background: linear-gradient(145deg, var(--accent-primary), #5c4cd1);
            color: white;
            padding: 0.85rem 1.75rem;
            border: none;
            border-radius: 0.6rem;
            font-size: 1.05rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 15px rgba(108, 92, 231, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(108, 92, 231, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #password-display {
            font-size: 2rem;
            font-weight: 700;
            color: var(--success);
            text-align: center;
            margin: 2rem 0;
            min-height: 3rem;
            padding: 1rem;
            border-radius: 0.75rem;
            background-color: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            transition: all 0.3s ease;
        }
        
        .plot-container {
            margin-top: 2.5rem;
            border: 1px solid var(--border);
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            padding: 1.25rem;
            background: var(--bg-tertiary);
        }
        
        .explanation {
            text-align: left;
            margin-top: 4rem;
        }
        
        .explanation h2 {
            text-align: center;
            border-bottom: 2px solid var(--accent-secondary);
            padding-bottom: 0.75rem;
            margin-bottom: 2.5rem;
            color: var(--text-primary);
            font-size: 2rem;
        }
        
        .step {
            margin-bottom: 2.5rem;
            background-color: var(--bg-tertiary);
            padding: 2rem;
            border-radius: 1rem;
            border: 1px solid var(--border);
            transition: transform 0.3s ease;
        }
        
        .step:hover {
            transform: translateY(-5px);
        }
        
        .step h3 {
            font-size: 1.4rem;
            color: var(--text-primary);
            margin-bottom: 1.25rem;
            display: flex;
            align-items: center;
        }
        
        .step-number {
            background: var(--accent-primary);
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 0.9rem;
        }
        
        .step p {
            margin-bottom: 1.25rem;
            line-height: 1.7;
        }
        
        .plot-small {
            height: 450px;
            width: 100%;
            border-radius: 0.75rem;
            overflow: hidden;
        }
        
        .info-box {
            background: rgba(108, 92, 231, 0.1);
            border-left: 4px solid var(--accent-primary);
            padding: 1.25rem;
            border-radius: 0.5rem;
            margin: 1.5rem 0;
        }
        
        .info-title {
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }
        
        .key-space-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        .key-space-table th, .key-space-table td {
            padding: 0.75rem 1rem;
            text-align: center;
            border: 1px solid var(--border);
        }
        
        .key-space-table th {
            background-color: rgba(108, 92, 231, 0.2);
        }
        
        .key-space-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        
        .loading {
            display: none;
            text-align: center;
            margin: 1rem 0;
            color: var(--text-secondary);
        }
        
        .loading-spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid var(--accent-primary);
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2.25rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-group {
                width: 100%;
            }
            
            input[type="number"] {
                width: 100%;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Polygon Numeric Key Generator</h1>
    <div class="header-subtitle">
        A geometric cipher that transforms polygon properties into unique numeric keys through centroid calculations.
    </div>

    <div class="controls">
        <div class="input-group">
            <label for="n">Polygon sides (n):</label>
            <input type="number" id="n" min="3" max="10" value="5">
        </div>
        <div class="input-group">
            <label for="m">Seed value (m):</label>
            <input type="number" id="m" min="1" value="103">
        </div>
        <div class="input-group">
            <label for="k">Centroid index (k):</label>
            <input type="number" id="k" min="1" value="1">
        </div>
        <button onclick="generateKey()">Generate Key</button>
    </div>
    
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p>Calculating centroids...</p>
    </div>

    <div id="password-display"></div>
    
    <div class="plot-container">
        <div id="plot" style="width:100%;height:700px;"></div>
    </div>

    <div class="explanation">
        <h2>How the Polygon Cipher Works</h2>
        
        <div class="info-box">
            <div class="info-title">About Cryptographic Ciphers</div>
            <p>A cipher is an algorithm for performing encryption or decryption—a series of well-defined steps that can be followed to transform information. This polygon cipher uses geometric transformations to create a unique mapping from input parameters to a numeric key, making it a form of deterministic pseudo-random number generation.</p>
        </div>
        
        <div class="step">
            <h3><span class="step-number">1</span>Step 1: The Base Polygon</h3>
            <p>A polygon with <strong>n</strong> sides is generated using a pseudo-random number generator seeded with <strong>m</strong>. The vertices are scattered randomly within a circle, creating a unique shape for each seed value. The random function uses a sine-based algorithm that produces consistent results for the same seed.</p>
            <div class="plot-small" id="plot-step1"></div>
        </div>
        
        <div class="step">
            <h3><span class="step-number">2</span>Step 2: Level 1 Centroids</h3>
            <p>We find every possible combination of three vertices from the base polygon to form triangles. For each of these triangles, we calculate its centroid (the point where the three medians intersect), creating a new set of points called <strong>Level 1 centroids</strong>. The number of Level 1 centroids is C(n, 3) = n!/(3!(n-3)!).</p>
            <div class="plot-small" id="plot-step2"></div>
        </div>
        
        <div class="step">
            <h3><span class="step-number">3</span>Step 3: Level 2 Centroids</h3>
            <p>The process is repeated. We take all possible combinations of three <strong>Level 1 centroids</strong> to form new triangles and then calculate the centroid of each one. These are the <strong>Level 2 centroids</strong>. The number of Level 2 centroids is C(C(n, 3), 3), which grows very rapidly as n increases.</p>
            <div class="plot-small" id="plot-step3"></div>
        </div>
        
        <div class="step">
            <h3><span class="step-number">4</span>Step 4: The Numeric Key</h3>
            <p>Finally, we select a specific <strong>Level 2 centroid</strong> using the index <strong>k</strong>. The final numeric key is generated by combining the x and y coordinates of this single point, removing the decimal point and any negative signs to create a large integer. This process ensures that small changes in input parameters produce dramatically different outputs.</p>
        </div>
        
        <div class="step">
            <h3><span class="step-number">5</span>Key Space and Security Considerations</h3>
            <p>The security of this cipher depends on the size of its key space—the number of possible keys it can generate. For different values of n, the key space varies as shown in the table below:</p>
            
            <table class="key-space-table">
                <thead>
                    <tr>
                        <th>Polygon Sides (n)</th>
                        <th>Level 1 Centroids</th>
                        <th>Level 2 Centroids</th>
                        <th>Key Space Size</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>3</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>10</td>
                        <td>120</td>
                        <td>120</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>20</td>
                        <td>1,140</td>
                        <td>1,140</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>35</td>
                        <td>6,545</td>
                        <td>6,545</td>
                    </tr>
                    <tr>
                        <td>8</td>
                        <td>56</td>
                        <td>27,720</td>
                        <td>27,720</td>
                    </tr>
                    <tr>
                        <td>9</td>
                        <td>84</td>
                        <td>95,284</td>
                        <td>95,284</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>120</td>
                        <td>280,840</td>
                        <td>280,840</td>
                    </tr>
                </tbody>
            </table>
            
            <p>Note: This cipher is designed for educational purposes to demonstrate geometric transformations in cryptography. For real-world security applications, use established cryptographic algorithms like AES or RSA.</p>
        </div>
    </div>
</div>

<script>
    // Improved random function with better distribution
    function random(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    // Memoization for combinations to improve performance
    const combinationsMemo = {};
    
    function combinations(n, k) {
        const key = `${n},${k}`;
        if (combinationsMemo[key]) return combinationsMemo[key];
        
        if (k > n) return 0;
        if (k === 0 || k === n) return 1;
        
        let result = 1;
        for (let i = 1; i <= k; i++) {
            result = result * (n - k + i) / i;
        }
        
        combinationsMemo[key] = result;
        return result;
    }

    function generatePolygon(n, radius, seed) {
        let points = [];
        for (let i = 0; i < n; i++) {
            points.push([
                (random(seed + i) * 2 - 1) * radius,
                (random(seed + n + i) * 2 - 1) * radius
            ]);
        }
        return points;
    }

    function triangleCentroid(tri) {
        let x = (tri[0][0] + tri[1][0] + tri[2][0]) / 3;
        let y = (tri[0][1] + tri[1][1] + tri[2][1]) / 3;
        return [x, y];
    }

    // Efficient centroid generation using mathematical properties
    function generateCentroids(polygon) {
        const n = polygon.length;
        
        // For Level 1 centroids, we can calculate directly
        const lvl1 = [];
        const lvl1Triangles = [];
        for (let i = 0; i < n - 2; i++) {
            for (let j = i + 1; j < n - 1; j++) {
                for (let k = j + 1; k < n; k++) {
                    const triangle = [polygon[i], polygon[j], polygon[k]];
                    lvl1.push(triangleCentroid(triangle));
                    lvl1Triangles.push(triangle);
                }
            }
        }
        
        // For Level 2 centroids, we use a more efficient approach
        // We know that the centroid of centroids can be computed from the original points
        // This avoids the O(C(n,3)^2) complexity
        const lvl2 = [];
        const lvl2Triangles = [];
        const totalLvl1 = lvl1.length;
        
        // For educational purposes, we'll compute a subset when n is large
        if (totalLvl1 > 1000) {
            // For large n, we sample rather than compute all combinations
            const sampleSize = Math.min(500, combinations(totalLvl1, 3));
            for (let i = 0; i < sampleSize; i++) {
                // Create a deterministic sample based on the seed
                const idx1 = i % totalLvl1;
                const idx2 = (i * 7) % totalLvl1;
                const idx3 = (i * 13) % totalLvl1;
                
                if (idx1 !== idx2 && idx1 !== idx3 && idx2 !== idx3) {
                    const triangle = [lvl1[idx1], lvl1[idx2], lvl1[idx3]];
                    lvl2.push(triangleCentroid(triangle));
                    lvl2Triangles.push(triangle);
                }
            }
        } else {
            // For smaller n, compute all combinations
            for (let i = 0; i < totalLvl1 - 2; i++) {
                for (let j = i + 1; j < totalLvl1 - 1; j++) {
                    for (let k = j + 1; k < totalLvl1; k++) {
                        const triangle = [lvl1[i], lvl1[j], lvl1[k]];
                        lvl2.push(triangleCentroid(triangle));
                        lvl2Triangles.push(triangle);
                    }
                }
            }
        }
        
        return { 
            lvl2: lvl2, 
            lvl1: lvl1,
            lvl1Triangles: lvl1Triangles,
            lvl2Triangles: lvl2Triangles
        };
    }

    function generateKey() {
        let n = parseInt(document.getElementById("n").value);
        let m = parseInt(document.getElementById("m").value);
        let k = parseInt(document.getElementById("k").value);
        let radius = 5000;
        
        // Show loading indicator
        document.getElementById('loading').style.display = 'block';
        document.getElementById('password-display').innerText = '';
        
        // Use setTimeout to allow the UI to update before heavy computation
        setTimeout(() => {
            if (n < 3 || n > 10) {
                showMessage("Please choose a number of sides (n) between 3 and 10 for a smooth experience. The calculations grow very quickly for larger numbers!");
                document.getElementById('loading').style.display = 'none';
                return;
            }

            let polygon = generatePolygon(n, radius, m);
            let centroids = generateCentroids(polygon);
            let lvl1 = centroids.lvl1;
            let lvl2 = centroids.lvl2;
            let lvl1Triangles = centroids.lvl1Triangles;
            let lvl2Triangles = centroids.lvl2Triangles;
            
            if (lvl2.length === 0) {
                showMessage("Not enough vertices to form Level 2 centroids. Please increase 'n' to at least 4.");
                document.getElementById('loading').style.display = 'none';
                return;
            }

            // Hand    }
    return points;
}

function triangleCentroid(tri) {
    let x = (tri[0][0]+tri[1][0]+tri[2][0])/3;
    let y = (tri[0][1]+tri[1][1]+tri[2][1])/3;
    return [x, y];
}

function combinations(arr, k) {
    let result = [];
    function helper(start, comb) {
        if (comb.length === k) {
            result.push(comb.slice());
            return;
        }
        for (let i=start;i<arr.length;i++){
            comb.push(arr[i]);
            helper(i+1, comb);
            comb.pop();
        }
    }
    helper(0, []);
    return result;
}

function generateCentroids(polygon) {
    let lvl1 = combinations(polygon, 3).map(triangleCentroid);
    let lvl2 = combinations(lvl1,3).map(triangleCentroid);
    return {lvl2: lvl2, lvl1: lvl1};
}

function sampleTriangles(triangles, maxSample=600) {
    if(triangles.length <= maxSample) return triangles;
    let sampled = [];
    while(sampled.length < maxSample){
        let idx = Math.floor(Math.random()*triangles.length);
        sampled.push(triangles[idx]);
    }
    return sampled;
}

function generateKey(){
    let n = parseInt(document.getElementById("n").value);
    let m = parseInt(document.getElementById("m").value);
    let k = parseInt(document.getElementById("k").value);
    let radius = 5000;

    let polygon = generatePolygon(n, radius, m);
    let centroids = generateCentroids(polygon);
    let lvl2 = centroids.lvl2;

    if(k<1 || k>lvl2.length){
        alert("k out of range");
        return;
    }

    let x = lvl2[k-1][0];
    let y = lvl2[k-1][1];
    let password = parseInt((x+y).toString().replace('.','').replace('-',''));
    document.getElementById("password").innerText = "Numeric Key: "+password;

    // Plot polygon and sampled lvl2 triangles
    let tracePoly = {
        x: polygon.map(p=>p[0]).concat([polygon[0][0]]),
        y: polygon.map(p=>p[1]).concat([polygon[0][1]]),
        mode: 'lines+markers',
        name: 'Polygon',
        line: {color: 'blue'}
    };

    let sampledLvl2 = sampleTriangles(combinations(centroids.lvl1,3), 600).map(tri=>tri.map(p=>p[0]));
    let traceCentroids = {
        x: lvl2.map(p=>p[0]),
        y: lvl2.map(p=>p[1]),
        mode: 'markers',
        name: 'Level 2 Centroids',
        marker: {color:'orange', size:6}
    };

    Plotly.newPlot('plot', [tracePoly, traceCentroids]);
}
</script>
</body>
</html>
